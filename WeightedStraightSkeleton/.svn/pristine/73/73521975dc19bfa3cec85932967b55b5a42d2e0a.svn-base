<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_20) on Wed Oct 06 13:54:23 CEST 2010 -->
<TITLE>
MyVectormath
</TITLE>

<META NAME="date" CONTENT="2010-10-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MyVectormath";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MyVectormath.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?math/MyVectormath.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MyVectormath.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
math</FONT>
<BR>
Class MyVectormath</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>math.MyVectormath</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>MyVectormath</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Patrick Gunia</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#debugMath">debugMath</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;<A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#mInstance">mInstance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#roundAccuracy">roundAccuracy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#tolerance">tolerance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private </CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#MyVectormath()">MyVectormath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateAngle(graphics.MyVector3f, graphics.MyVector3f)">calculateAngle</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vec1,
               <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vec2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet den Winkel zwischen zwei Vektoren, Vorteil sind kleinere bis keine Rundungsfehler</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateOrthogonalVectorWithSamePlane(graphics.MyVector3f, graphics.MyVector3f)">calculateOrthogonalVectorWithSamePlane</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;source,
                                       <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;normal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode berechnet einen orthogonalen Vektor zum uebergebenen Source-Vektor basierend
  auf einer 90°-Drehung um die Vertex-Normale</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateParameterOnRayForPoint(graphics.MyVector3f, graphics.Ray)">calculateParameterOnRayForPoint</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode berechnet den Parameter k in der Punkt-Richtungsdarstellung der Geraden
 Geht davon aus, dass der Punkt auf der Geraden liegt</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculatePlane2PlaneIntersectionDirection(graphics.Plane, graphics.Plane)">calculatePlane2PlaneIntersectionDirection</A></B>(<A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane1,
                                          <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet die Richtung der Schnittgeraden zweier Ebenen
 gibt null zurueck, wenn die Ebenen parallel oder identisch sind,
 sonst den Richtungsvektor</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculatePlanePlanePlaneIntersection(graphics.Plane, graphics.Plane, graphics.Plane)">calculatePlanePlanePlaneIntersection</A></B>(<A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane1,
                                     <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane2,
                                     <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet den Schnittpunkt 3er Ebenen ueber den JAMA-Matrix-Solver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculatePointEdgeDistance(graphics.MyVector3f, graphics.Ray)">calculatePointEdgeDistance</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                           <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;edge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet die Distanz des Punktes point von der Geraden edge
  Formel: d(point, edge) = |(a-b) x r| / |r|
  a := Ortsvektor von Point
  b := Stuetzvektor der Geraden
  r := Richtungsvektor der Geraden
  http://www.tutorials.de/java/340809-abstand-punkt-zu-gerade.html</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculatePointPlaneDistance(graphics.MyVector3f, graphics.Plane)">calculatePointPlaneDistance</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                            <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet den senkrechten Abstand des Punktes von der Ebene</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculatePointPointDistance(graphics.MyVector3f, graphics.MyVector3f)">calculatePointPointDistance</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point1,
                            <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode zur Berechnung des Abstands zweier Punkte im 3-dimensionalen Raum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateRay2RayIntersection3DVectorStyle(graphics.Ray, graphics.Ray)">calculateRay2RayIntersection3DVectorStyle</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                                          <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateRay2RayIntersectionMatrixStyle(graphics.Ray, graphics.Ray)">calculateRay2RayIntersectionMatrixStyle</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                                        <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet den Schnittpunkt zweier Geraden im 3-dimensionalen Raum durch Loesen des zugehorigen Gleichungssystems
 ueber die JAMA-Matrix-Solver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateRayPlaneIntersection(graphics.Ray, graphics.Plane)">calculateRayPlaneIntersection</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                              <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnung des Schnittpunktes einer Geraden mit einer Ebene
 Ebene wird in hessescher Normalenform angebeben mit Normalen- und Stuetzvektor
 Gerade als Punkt- Richtungs-Form
 es gilt: 
 t = (N * (d - P0)) / (N * V)
 mit: 
 P0 := Stuetzvektor der Geraden
 N  := Normalenvektor der Ebene
 d  := Stuetzvektor der Ebene
 V  := Richtungsvektor der Geraden
 wenn t = 0, dann ist Gerade entweder echt parallel zur Ebene oder in dieser enthalten
 sonst ist der Schnittpunkt P (einsetzen in die Geradengleichung):
 P = P0 + tV</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateRayPlaneIntersectionNewSchool(graphics.Ray, graphics.Plane)">calculateRayPlaneIntersectionNewSchool</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                                       <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method berechnet den Schnittpunkt einer Geraden und einer Ebene durch das Gleichsetzen der
 Punkt-Richtungsform der Geraden mit der Parameterform der Ebene.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateRotatedVector(graphics.MyVector3f, graphics.MyVector3f, float)">calculateRotatedVector</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;axis,
                       <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector,
                       float&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diese Funktion rotiert den uebergebenen Vektor um die uebergebene Achse um den uebergebenen Winkel
 basiert auf der Aufstellung einer Rotationsmatrix basierend auf der Rotationsachse
 diese muss normalisiert werden, damit es sich um einen Einheitsvektor handelt
 Definition Drehmatrix um beliebige Achse: http://de.wikipedia.org/wiki/Drehmatrix#Drehmatrizen_des_Raumes_R.C2.B3
 Variablennamen orientieren sich am Wikipedia-Artikel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../algorithm/SkeletonTriangle.html" title="class in algorithm">SkeletonTriangle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateScaledTriangle(graphics.Vertex3d[])">calculateScaledTriangle</A></B>(<A HREF="../graphics/Vertex3d.html" title="class in graphics">Vertex3d</A>[]&nbsp;points)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode berechnet aus drei Punkten ein skaliertes Dreieck, bei dem die Eingabeeckpunkte
 um einen bestimmten prozentualen Anteil des Umfangs in Richtung ihrer Winkelhalbierenden
 verschoben werden, dadurch entsteht ein Dreieck mit groesserer Flaeche aber gleichen Proportionen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateWinkelhalbierende(graphics.Ray, graphics.Ray)">calculateWinkelhalbierende</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                           <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet die Winkelhalbierende der beiden uebergebenen Rays
 Die Winkelhalbierende zweier Vektoren a und b mit gemeinsamem Stuetzpunkt C
 berechnet sich durch die Addition der Einheitsvektoren von a und b
 http://www.mathe-online.at/mathint/vect1/i.html#30</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#calculateWinkelhalbierendeForReflexVertex(algorithm.SkeletonVertex)">calculateWinkelhalbierendeForReflexVertex</A></B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;vertex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handelt es sich bei dem betrachteten Vertex um ein Reflex-Vertex, so muss
 die Winkelhalbierende basierend auf dem Reflexionsgesetz (Einfallswinkel
 = Ausfallswinkel) neu berechnet werden Formel: (R = 2N(N*L)-L) mit: L :=
 berechnete Winkelhalbierende fuer spitzen Winkel N := Vertexnormale R :=
 berechneter Reflexionsvektor</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#getAngle2d(graphics.MyVector2f, graphics.MyVector2f)">getAngle2d</A></B>(<A HREF="../graphics/MyVector2f.html" title="class in graphics">MyVector2f</A>&nbsp;rot1,
           <A HREF="../graphics/MyVector2f.html" title="class in graphics">MyVector2f</A>&nbsp;rot2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-dimesionales Skalarprodukt => berechnet das Skalarprodukt der uebergebenen 
 Vektoren im 2d-Raum
 http://www.spieleprogrammierer.de/index.php?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#getFullAngle(graphics.MyVector3f, graphics.MyVector3f)">getFullAngle</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input,
             <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet den Winkel zwischen zwei Vektoren durch Reduktion der Rechnung 
 auf 2d-Raeume => geht alle Ebenen durch und bestimmt dort die Skalarprodukt
 => gibt dann die Winkel als Vektor zurueck in Bezug auf alle 3-Ebenen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#getInstance()">getInstance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#getPointOnRay(graphics.Ray, float)">getPointOnRay</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
              float&nbsp;factor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diese Methode setzt den Faktor in die Geradengleichung des Strahls ein und gibt den
 so beschriebenen Punkt zurueck</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#getPointOnRayByHeight(graphics.Ray, float)">getPointOnRayByHeight</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                      float&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet einen Punkt auf dem uebergebenen Strahl mit der Zielhoehe
  nimm die Parameterdarstellung und berechne den Parameter fuer die Hoehe</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isOrthogonal(graphics.MyVector3f, graphics.MyVector3f)">isOrthogonal</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector1,
             <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode bestimmt, ob zwei Vektoren senkrecht zueinander sind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isParallel(graphics.MyVector3f, graphics.MyVector3f)">isParallel</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector1,
           <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet, ob zwei Vektoren parallel sind => wenn das Punktprodukt gleich dem Produkt der Betraege ist</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isPointInTriangle(graphics.MyVector3f, algorithm.SkeletonTriangle)">isPointInTriangle</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                  <A HREF="../algorithm/SkeletonTriangle.html" title="class in algorithm">SkeletonTriangle</A>&nbsp;triangle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode testet, ob sich ein Punkt innerhalb eines Dreiecks befindet => dafuer verwendet wird
 isSameSideOfRay fuer alle 3 Kanten => sobald der Punkt fuer eine Kante auf der anderen Seite ist,
 kann der Test abgebrochen werden (als Referenzpunkt wird immer jeweils der 3.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isPointOnLineSegment(graphics.MyVector3f, graphics.Ray)">isPointOnLineSegment</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                     <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet, ob sich der Punkt auf dem Liniensegment befindet, das durch die PunktRichtungsform beschrieben wird.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isPointOnPlane(graphics.MyVector3f, graphics.Plane)">isPointOnPlane</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
               <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet durch Einsetzen des Punktes in die Koordinatendarstellung der Ebene, ob der Punkt in der Ebene liegt</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isPointOnRay(graphics.MyVector3f, graphics.Ray)">isPointOnRay</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
             <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet, ob der uebergebene Punkt auf der Gerade liegt, dies ist dann der Fall,
  wenn der Abstand zwischen Punkt und Gerade 0 ist</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isReflexVertex(graphics.Ray, graphics.Ray)">isReflexVertex</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
               <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diese Methode dient der Bestimmung von Reflex-Vertices => hierbei handelt
 es sich um Vertices in konkaven Polygonen, deren adjazente Kanten einen
 stumpfen Winkel bilden Die Bestimmung, ob ein Vertex ein Relfex-Vertex
 ist, besteht in der Berechnung des Winkels zwischen seinen adjazenten
 Kanten</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isSameSideOfRay(graphics.Ray, graphics.MyVector3f, graphics.MyVector3f)">isSameSideOfRay</A></B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point1,
                <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diese Funktion prueft, ob sich Punkt1 und Punkt2 auf der gleichen Seite in Bezug auf den uebergebenen Strahl befinden
 fuer Punkt 2 muss bekannt sein, wo sich dieser befindet => wenn nun das Kreuzprodukt des Richtungsvektors des Strahls mit 
 dem vektor vom Startpunkt des Strahls mit Punkt1 die gleiche gleiche Richtung besitzt wie mit Punkt2, so liegen die Punkte
 auf der gleichen Seite
 Algorithmus:
 http://www.blackpawn.com/texts/pointinpoly/default.html</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#isWithinTolerance(float, float)">isWithinTolerance</A></B>(float&nbsp;value,
                  float&nbsp;targetValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestimmt, ob der uebergebene Wert nicht mehr als tolerance vom Zielwert abweicht</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#print(double[][])">print</A></B>(double[][]&nbsp;matrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utilitymethode zur Ausgabe einer Matrix</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#round(double, float)">round</A></B>(double&nbsp;input,
      float&nbsp;accuracy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rundet einen uebergebenen Wert mit der uebergebenen Genauigkeit und gibt den gerundeten Wert zurueck</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#round(float)">round</A></B>(float&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rundet einen Float-Wert auf die festgelegte Anzahl an Nachkommastellen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#round(float, float)">round</A></B>(float&nbsp;input,
      float&nbsp;accuracy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rundet einen uebergebenen Wert mit der uebergebenen Genauigkeit und gibt den gerundeten Wert zurueck</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#roundVector3f(graphics.MyVector3f)">roundVector3f</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Funktion zum Runden von Vektoren</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../math/MyVectormath.html#roundVector3f(graphics.MyVector3f, float)">roundVector3f</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input,
              float&nbsp;accuracy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Funktion zum Runden von Vektoren mit uebergebener Genauigkeit</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="roundAccuracy"><!-- --></A><H3>
roundAccuracy</H3>
<PRE>
private final float <B>roundAccuracy</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#math.MyVectormath.roundAccuracy">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="tolerance"><!-- --></A><H3>
tolerance</H3>
<PRE>
private final float <B>tolerance</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#math.MyVectormath.tolerance">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="debugMath"><!-- --></A><H3>
debugMath</H3>
<PRE>
private final boolean <B>debugMath</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#math.MyVectormath.debugMath">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="mInstance"><!-- --></A><H3>
mInstance</H3>
<PRE>
private static <A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A> <B>mInstance</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MyVectormath()"><!-- --></A><H3>
MyVectormath</H3>
<PRE>
private <B>MyVectormath</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getInstance()"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static <A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A> <B>getInstance</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="calculateWinkelhalbierende(graphics.Ray, graphics.Ray)"><!-- --></A><H3>
calculateWinkelhalbierende</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateWinkelhalbierende</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                                             <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</PRE>
<DL>
<DD>berechnet die Winkelhalbierende der beiden uebergebenen Rays
 Die Winkelhalbierende zweier Vektoren a und b mit gemeinsamem Stuetzpunkt C
 berechnet sich durch die Addition der Einheitsvektoren von a und b
 http://www.mathe-online.at/mathint/vect1/i.html#30
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray1</CODE> - <DD><CODE>ray2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="calculateRay2RayIntersection3DVectorStyle(graphics.Ray, graphics.Ray)"><!-- --></A><H3>
calculateRay2RayIntersection3DVectorStyle</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateRay2RayIntersection3DVectorStyle</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                                                            <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>Algorithmus zur Berechnung eines Geradenschnittpunktes basierend auf der Methode nach Ronald Goldblum
 Verwendet Kreuzprodukte, wird hier beschrieben: 
 http://mathforum.org/library/drmath/view/62814.html
 http://mathforum.org/library/drmath/view/63719.html
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray1</CODE> - Eingabestrahl 1<DD><CODE>ray2</CODE> - Eingabestrahl 2
<DT><B>Returns:</B><DD>Schnittpunkt, sofern ein solcher existiert, NULL sonst</DL>
</DD>
</DL>
<HR>

<A NAME="calculateRay2RayIntersectionMatrixStyle(graphics.Ray, graphics.Ray)"><!-- --></A><H3>
calculateRay2RayIntersectionMatrixStyle</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateRay2RayIntersectionMatrixStyle</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                                                          <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</PRE>
<DL>
<DD>Berechnet den Schnittpunkt zweier Geraden im 3-dimensionalen Raum durch Loesen des zugehorigen Gleichungssystems
 ueber die JAMA-Matrix-Solver. Setzt die beiden Punkt-Richtungsformen der Strahlen gleich und berechnet guelgite Parameter.
 Sofern ein Schnittpunkt existiert, wird dieser zurueckgegeben, sonst NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray1</CODE> - Eingabestrahl1<DD><CODE>ray2</CODE> - Eingabestrahl2
<DT><B>Returns:</B><DD>Schnittpunkt, sofern ein solcher berechnet werden konnte, NULL sonst</DL>
</DD>
</DL>
<HR>

<A NAME="calculatePointEdgeDistance(graphics.MyVector3f, graphics.Ray)"><!-- --></A><H3>
calculatePointEdgeDistance</H3>
<PRE>
public float <B>calculatePointEdgeDistance</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                        <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;edge)</PRE>
<DL>
<DD>berechnet die Distanz des Punktes point von der Geraden edge
  Formel: d(point, edge) = |(a-b) x r| / |r|
  a := Ortsvektor von Point
  b := Stuetzvektor der Geraden
  r := Richtungsvektor der Geraden
  http://www.tutorials.de/java/340809-abstand-punkt-zu-gerade.html
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt<DD><CODE>edge</CODE> - Kante, zu der der senkrechte Abstand des Punktes berechnet wird
<DT><B>Returns:</B><DD>Abstand zwischen Punkt und Kante als Gleitpunktzahl</DL>
</DD>
</DL>
<HR>

<A NAME="calculatePointPointDistance(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
calculatePointPointDistance</H3>
<PRE>
public float <B>calculatePointPointDistance</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point1,
                                         <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point2)</PRE>
<DL>
<DD>Methode zur Berechnung des Abstands zweier Punkte im 3-dimensionalen Raum. Verfahren berechnet
 den Vebindungsvektor und verwendet dessen Laenge
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point1</CODE> - Eingabepunkt 1<DD><CODE>point2</CODE> - Eingabepunkt 2
<DT><B>Returns:</B><DD>Abstand der beiden Eingabepunkte als Gleitpunktzahl</DL>
</DD>
</DL>
<HR>

<A NAME="calculatePointPlaneDistance(graphics.MyVector3f, graphics.Plane)"><!-- --></A><H3>
calculatePointPlaneDistance</H3>
<PRE>
public float <B>calculatePointPlaneDistance</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                         <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</PRE>
<DL>
<DD>Berechnet den senkrechten Abstand des Punktes von der Ebene
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt<DD><CODE>plane</CODE> - Eingabeebene
<DT><B>Returns:</B><DD>Senkrechter Abstand des Punktes von der Ebene</DL>
</DD>
</DL>
<HR>

<A NAME="calculateRayPlaneIntersection(graphics.Ray, graphics.Plane)"><!-- --></A><H3>
calculateRayPlaneIntersection</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateRayPlaneIntersection</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                                                <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</PRE>
<DL>
<DD>Berechnung des Schnittpunktes einer Geraden mit einer Ebene
 Ebene wird in hessescher Normalenform angebeben mit Normalen- und Stuetzvektor
 Gerade als Punkt- Richtungs-Form
 es gilt: 
 t = (N * (d - P0)) / (N * V)
 mit: 
 P0 := Stuetzvektor der Geraden
 N  := Normalenvektor der Ebene
 d  := Stuetzvektor der Ebene
 V  := Richtungsvektor der Geraden
 wenn t = 0, dann ist Gerade entweder echt parallel zur Ebene oder in dieser enthalten
 sonst ist der Schnittpunkt P (einsetzen in die Geradengleichung):
 P = P0 + tV
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray</CODE> - Eingabestrahl<DD><CODE>plane</CODE> - Eingabeebene
<DT><B>Returns:</B><DD>Der berechnete Schnittpunkt</DL>
</DD>
</DL>
<HR>

<A NAME="calculateRayPlaneIntersectionNewSchool(graphics.Ray, graphics.Plane)"><!-- --></A><H3>
calculateRayPlaneIntersectionNewSchool</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateRayPlaneIntersectionNewSchool</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                                                         <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</PRE>
<DL>
<DD>Method berechnet den Schnittpunkt einer Geraden und einer Ebene durch das Gleichsetzen der
 Punkt-Richtungsform der Geraden mit der Parameterform der Ebene. Anschliessend loest man das
 entstehende Gleichungssystem ueber einen Matrix-Solver
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray</CODE> - Eingabestrahl<DD><CODE>plane</CODE> - Ebene, die auf Schnitte mit dem Strahl getestet wird
<DT><B>Returns:</B><DD>NULL, falls die Gerade echt parallel zur Ebene oder in dieser verlaeuft, sonst den Schnittpunkt</DL>
</DD>
</DL>
<HR>

<A NAME="print(double[][])"><!-- --></A><H3>
print</H3>
<PRE>
private void <B>print</B>(double[][]&nbsp;matrix)</PRE>
<DL>
<DD>Utilitymethode zur Ausgabe einer Matrix
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="calculateOrthogonalVectorWithSamePlane(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
calculateOrthogonalVectorWithSamePlane</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateOrthogonalVectorWithSamePlane</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;source,
                                                         <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;normal)</PRE>
<DL>
<DD>Methode berechnet einen orthogonalen Vektor zum uebergebenen Source-Vektor basierend
  auf einer 90°-Drehung um die Vertex-Normale
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - zu drehender Eingabevektor<DD><CODE>normal</CODE> - Normalenvektor am Fusspunkt des Eingabevektors
<DT><B>Returns:</B><DD>Der um den Normalenvektor gedrehte Eingabevektor</DL>
</DD>
</DL>
<HR>

<A NAME="calculateRotatedVector(graphics.MyVector3f, graphics.MyVector3f, float)"><!-- --></A><H3>
calculateRotatedVector</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateRotatedVector</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;axis,
                                         <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector,
                                         float&nbsp;angle)</PRE>
<DL>
<DD>diese Funktion rotiert den uebergebenen Vektor um die uebergebene Achse um den uebergebenen Winkel
 basiert auf der Aufstellung einer Rotationsmatrix basierend auf der Rotationsachse
 diese muss normalisiert werden, damit es sich um einen Einheitsvektor handelt
 Definition Drehmatrix um beliebige Achse: http://de.wikipedia.org/wiki/Drehmatrix#Drehmatrizen_des_Raumes_R.C2.B3
 Variablennamen orientieren sich am Wikipedia-Artikel
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>axis</CODE> - <DD><CODE>vector</CODE> - <DD><CODE>angle</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="calculateAngle(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
calculateAngle</H3>
<PRE>
public float <B>calculateAngle</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vec1,
                            <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vec2)</PRE>
<DL>
<DD>berechnet den Winkel zwischen zwei Vektoren, Vorteil sind kleinere bis keine Rundungsfehler
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vec1</CODE> - <DD><CODE>vec2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="getFullAngle(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
getFullAngle</H3>
<PRE>
public float <B>getFullAngle</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input,
                          <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input2)</PRE>
<DL>
<DD>berechnet den Winkel zwischen zwei Vektoren durch Reduktion der Rechnung 
 auf 2d-Raeume => geht alle Ebenen durch und bestimmt dort die Skalarprodukt
 => gibt dann die Winkel als Vektor zurueck in Bezug auf alle 3-Ebenen
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - <DD><CODE>input2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="getAngle2d(graphics.MyVector2f, graphics.MyVector2f)"><!-- --></A><H3>
getAngle2d</H3>
<PRE>
public float <B>getAngle2d</B>(<A HREF="../graphics/MyVector2f.html" title="class in graphics">MyVector2f</A>&nbsp;rot1,
                        <A HREF="../graphics/MyVector2f.html" title="class in graphics">MyVector2f</A>&nbsp;rot2)</PRE>
<DL>
<DD>2-dimesionales Skalarprodukt => berechnet das Skalarprodukt der uebergebenen 
 Vektoren im 2d-Raum
 http://www.spieleprogrammierer.de/index.php?page=Thread&threadID=3678
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rot1</CODE> - <DD><CODE>rot2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSameSideOfRay(graphics.Ray, graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
isSameSideOfRay</H3>
<PRE>
public boolean <B>isSameSideOfRay</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                               <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point1,
                               <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point2)</PRE>
<DL>
<DD>Diese Funktion prueft, ob sich Punkt1 und Punkt2 auf der gleichen Seite in Bezug auf den uebergebenen Strahl befinden
 fuer Punkt 2 muss bekannt sein, wo sich dieser befindet => wenn nun das Kreuzprodukt des Richtungsvektors des Strahls mit 
 dem vektor vom Startpunkt des Strahls mit Punkt1 die gleiche gleiche Richtung besitzt wie mit Punkt2, so liegen die Punkte
 auf der gleichen Seite
 Algorithmus:
 http://www.blackpawn.com/texts/pointinpoly/default.html
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray</CODE> - <DD><CODE>point1</CODE> - <DD><CODE>point2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="isPointInTriangle(graphics.MyVector3f, algorithm.SkeletonTriangle)"><!-- --></A><H3>
isPointInTriangle</H3>
<PRE>
public boolean <B>isPointInTriangle</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                 <A HREF="../algorithm/SkeletonTriangle.html" title="class in algorithm">SkeletonTriangle</A>&nbsp;triangle)</PRE>
<DL>
<DD>Methode testet, ob sich ein Punkt innerhalb eines Dreiecks befindet => dafuer verwendet wird
 isSameSideOfRay fuer alle 3 Kanten => sobald der Punkt fuer eine Kante auf der anderen Seite ist,
 kann der Test abgebrochen werden (als Referenzpunkt wird immer jeweils der 3. Punkt genommen
 Algorithmus:
 http://www.blackpawn.com/texts/pointinpoly/default.html
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt, fuer den getestet wird, ob er sich innerhalb des uebergebenen Dreiecks befindet<DD><CODE>triangle</CODE> - Eingabedreieck
<DT><B>Returns:</B><DD>True, falls sich der Punkt innerhalb des Dreiecks befindet, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="getPointOnRay(graphics.Ray, float)"><!-- --></A><H3>
getPointOnRay</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>getPointOnRay</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                                float&nbsp;factor)</PRE>
<DL>
<DD>Diese Methode setzt den Faktor in die Geradengleichung des Strahls ein und gibt den
 so beschriebenen Punkt zurueck
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray</CODE> - <DD><CODE>factor</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundVector3f(graphics.MyVector3f)"><!-- --></A><H3>
roundVector3f</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>roundVector3f</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input)</PRE>
<DL>
<DD>Funktion zum Runden von Vektoren
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="round(float)"><!-- --></A><H3>
round</H3>
<PRE>
public float <B>round</B>(float&nbsp;input)</PRE>
<DL>
<DD>rundet einen Float-Wert auf die festgelegte Anzahl an Nachkommastellen
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - Zu rundender Wert
<DT><B>Returns:</B><DD>Wert, der auf die festgelegte Anzahl an Nachkommastellen gerundet ist</DL>
</DD>
</DL>
<HR>

<A NAME="round(float, float)"><!-- --></A><H3>
round</H3>
<PRE>
public float <B>round</B>(float&nbsp;input,
                   float&nbsp;accuracy)</PRE>
<DL>
<DD>Rundet einen uebergebenen Wert mit der uebergebenen Genauigkeit und gibt den gerundeten Wert zurueck
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - Zu rundendender Wert<DD><CODE>accuracy</CODE> - Rundungsgenauigkeit
<DT><B>Returns:</B><DD>gerundeter Wert</DL>
</DD>
</DL>
<HR>

<A NAME="round(double, float)"><!-- --></A><H3>
round</H3>
<PRE>
public double <B>round</B>(double&nbsp;input,
                    float&nbsp;accuracy)</PRE>
<DL>
<DD>Rundet einen uebergebenen Wert mit der uebergebenen Genauigkeit und gibt den gerundeten Wert zurueck
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - Zu rundendender Wert als double<DD><CODE>accuracy</CODE> - Rundungsgenauigkeit
<DT><B>Returns:</B><DD>gerundeter Wert</DL>
</DD>
</DL>
<HR>

<A NAME="roundVector3f(graphics.MyVector3f, float)"><!-- --></A><H3>
roundVector3f</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>roundVector3f</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;input,
                                float&nbsp;accuracy)</PRE>
<DL>
<DD>Funktion zum Runden von Vektoren mit uebergebener Genauigkeit
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - Zu rundender Vektor<DD><CODE>accuracy</CODE> - Rundungsgenauigkeit
<DT><B>Returns:</B><DD>gerundeter Vektor</DL>
</DD>
</DL>
<HR>

<A NAME="isPointOnRay(graphics.MyVector3f, graphics.Ray)"><!-- --></A><H3>
isPointOnRay</H3>
<PRE>
public boolean <B>isPointOnRay</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                            <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</PRE>
<DL>
<DD>Testet, ob der uebergebene Punkt auf der Gerade liegt, dies ist dann der Fall,
  wenn der Abstand zwischen Punkt und Gerade 0 ist
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt<DD><CODE>ray</CODE> - Eingabestrahl
<DT><B>Returns:</B><DD>True, falls der Punkt auf dem Eingabestrahl liegt, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="isPointOnLineSegment(graphics.MyVector3f, graphics.Ray)"><!-- --></A><H3>
isPointOnLineSegment</H3>
<PRE>
public boolean <B>isPointOnLineSegment</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                    <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</PRE>
<DL>
<DD>Testet, ob sich der Punkt auf dem Liniensegment befindet, das durch die PunktRichtungsform beschrieben wird.
 Dies ist der Fall, falls ein Parameter k im Bereich von 0 bis 1 gefunden werden kann, so dass das Einsetzen
 dieses Parameters den angeforderten Punkt ergibt
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt<DD><CODE>ray</CODE> - Eingabestrahl
<DT><B>Returns:</B><DD>True, falls ein Parameter gefunden werden konnte, der die Bedingungen erfuellt, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="calculateParameterOnRayForPoint(graphics.MyVector3f, graphics.Ray)"><!-- --></A><H3>
calculateParameterOnRayForPoint</H3>
<PRE>
public double <B>calculateParameterOnRayForPoint</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                                              <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray)</PRE>
<DL>
<DD>Methode berechnet den Parameter k in der Punkt-Richtungsdarstellung der Geraden
 Geht davon aus, dass der Punkt auf der Geraden liegt
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Punkt auf dem Strahl<DD><CODE>ray</CODE> - Strahl
<DT><B>Returns:</B><DD>Parameter in der Punkt-Richtungsdarstellung der Geraden, der bei Einsetzen den Punkt ergibt</DL>
</DD>
</DL>
<HR>

<A NAME="isPointOnPlane(graphics.MyVector3f, graphics.Plane)"><!-- --></A><H3>
isPointOnPlane</H3>
<PRE>
public boolean <B>isPointOnPlane</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;point,
                              <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane)</PRE>
<DL>
<DD>Testet durch Einsetzen des Punktes in die Koordinatendarstellung der Ebene, ob der Punkt in der Ebene liegt
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - Eingabepunkt<DD><CODE>plane</CODE> - Eingabeebene
<DT><B>Returns:</B><DD>True, falls der Punkt in der Ebene liegt, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="isReflexVertex(graphics.Ray, graphics.Ray)"><!-- --></A><H3>
isReflexVertex</H3>
<PRE>
public boolean <B>isReflexVertex</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray1,
                              <A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray2)</PRE>
<DL>
<DD>Diese Methode dient der Bestimmung von Reflex-Vertices => hierbei handelt
 es sich um Vertices in konkaven Polygonen, deren adjazente Kanten einen
 stumpfen Winkel bilden Die Bestimmung, ob ein Vertex ein Relfex-Vertex
 ist, besteht in der Berechnung des Winkels zwischen seinen adjazenten
 Kanten
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray1</CODE> - <DD><CODE>ray2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="calculateWinkelhalbierendeForReflexVertex(algorithm.SkeletonVertex)"><!-- --></A><H3>
calculateWinkelhalbierendeForReflexVertex</H3>
<PRE>
public void <B>calculateWinkelhalbierendeForReflexVertex</B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;vertex)</PRE>
<DL>
<DD>handelt es sich bei dem betrachteten Vertex um ein Reflex-Vertex, so muss
 die Winkelhalbierende basierend auf dem Reflexionsgesetz (Einfallswinkel
 = Ausfallswinkel) neu berechnet werden Formel: (R = 2N(N*L)-L) mit: L :=
 berechnete Winkelhalbierende fuer spitzen Winkel N := Vertexnormale R :=
 berechneter Reflexionsvektor
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="calculatePlane2PlaneIntersectionDirection(graphics.Plane, graphics.Plane)"><!-- --></A><H3>
calculatePlane2PlaneIntersectionDirection</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculatePlane2PlaneIntersectionDirection</B>(<A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane1,
                                                            <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane2)</PRE>
<DL>
<DD>Berechnet die Richtung der Schnittgeraden zweier Ebenen
 gibt null zurueck, wenn die Ebenen parallel oder identisch sind,
 sonst den Richtungsvektor
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plane1</CODE> - <DD><CODE>plane2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="isParallel(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
isParallel</H3>
<PRE>
public boolean <B>isParallel</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector1,
                          <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector2)</PRE>
<DL>
<DD>berechnet, ob zwei Vektoren parallel sind => wenn das Punktprodukt gleich dem Produkt der Betraege ist
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vector1</CODE> - <DD><CODE>vector2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="isOrthogonal(graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
isOrthogonal</H3>
<PRE>
public boolean <B>isOrthogonal</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector1,
                            <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;vector2)</PRE>
<DL>
<DD>Methode bestimmt, ob zwei Vektoren senkrecht zueinander sind. Dies ist der Fall, wenn 
 ihr Punktprodukt = 0.0f ist
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vector1</CODE> - Eingabevektor 1<DD><CODE>vector2</CODE> - Eingabevektor 2
<DT><B>Returns:</B><DD>True, wenn die Vektoren senkrecht zueinander stehen, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="isWithinTolerance(float, float)"><!-- --></A><H3>
isWithinTolerance</H3>
<PRE>
public boolean <B>isWithinTolerance</B>(float&nbsp;value,
                                 float&nbsp;targetValue)</PRE>
<DL>
<DD>bestimmt, ob der uebergebene Wert nicht mehr als tolerance vom Zielwert abweicht
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - <DD><CODE>targetValue</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="getPointOnRayByHeight(graphics.Ray, float)"><!-- --></A><H3>
getPointOnRayByHeight</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>getPointOnRayByHeight</B>(<A HREF="../graphics/Ray.html" title="class in graphics">Ray</A>&nbsp;ray,
                                        float&nbsp;height)</PRE>
<DL>
<DD>berechnet einen Punkt auf dem uebergebenen Strahl mit der Zielhoehe
  nimm die Parameterdarstellung und berechne den Parameter fuer die Hoehe
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ray</CODE> - <DD><CODE>height</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="calculatePlanePlanePlaneIntersection(graphics.Plane, graphics.Plane, graphics.Plane)"><!-- --></A><H3>
calculatePlanePlanePlaneIntersection</H3>
<PRE>
public <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculatePlanePlanePlaneIntersection</B>(<A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane1,
                                                       <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane2,
                                                       <A HREF="../graphics/Plane.html" title="class in graphics">Plane</A>&nbsp;plane3)</PRE>
<DL>
<DD>berechnet den Schnittpunkt 3er Ebenen ueber den JAMA-Matrix-Solver
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plane1</CODE> - <DD><CODE>plane2</CODE> - <DD><CODE>plane3</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="calculateScaledTriangle(graphics.Vertex3d[])"><!-- --></A><H3>
calculateScaledTriangle</H3>
<PRE>
public <A HREF="../algorithm/SkeletonTriangle.html" title="class in algorithm">SkeletonTriangle</A> <B>calculateScaledTriangle</B>(<A HREF="../graphics/Vertex3d.html" title="class in graphics">Vertex3d</A>[]&nbsp;points)</PRE>
<DL>
<DD>Methode berechnet aus drei Punkten ein skaliertes Dreieck, bei dem die Eingabeeckpunkte
 um einen bestimmten prozentualen Anteil des Umfangs in Richtung ihrer Winkelhalbierenden
 verschoben werden, dadurch entsteht ein Dreieck mit groesserer Flaeche aber gleichen Proportionen
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>points</CODE> - Eingabepunkte des zu skalierenden Dreieecks
<DT><B>Returns:</B><DD>Das skalierte Dreieck</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MyVectormath.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?math/MyVectormath.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MyVectormath.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
