<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_20) on Wed Oct 06 13:54:24 CEST 2010 -->
<TITLE>
SkeletonJob
</TITLE>

<META NAME="date" CONTENT="2010-10-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SkeletonJob";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SkeletonJob.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../algorithm/SkeletonEdge.html" title="class in algorithm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?algorithm/SkeletonJob.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SkeletonJob.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
algorithm</FONT>
<BR>
Class SkeletonJob</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>algorithm.SkeletonJob</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Runnable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>SkeletonJob</B><DT>extends java.lang.Object<DT>implements java.lang.Runnable</DL>
</PRE>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Patrick Gunia
 
 ein SkeletonJob besteht aus einem Polygon, das verarbeitet wird und aus einer Reihe von Steuervariablen,
 die nur fuer diesen Job gelten</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mChildBuffer">mChildBuffer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mCompletedFirstIteration">mCompletedFirstIteration</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mErrorsOccured">mErrorsOccured</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.Vector&lt;<A HREF="../algorithm/iStraightSkeletonEvent.html" title="interface in algorithm">iStraightSkeletonEvent</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mEvents">mEvents</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mFoundReflexVertex">mFoundReflexVertex</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mLevel">mLevel</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mLineBreak">mLineBreak</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mMathHelper">mMathHelper</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mPolygon">mPolygon</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.Vector&lt;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mPolygonBuffer">mPolygonBuffer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mSplitEventOccured">mSplitEventOccured</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mVertexEventOccured">mVertexEventOccured</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#mVertexEventPossible">mVertexEventPossible</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#SkeletonJob(algorithm.SkeletonPolygon, int, boolean)">SkeletonJob</A></B>(<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A>&nbsp;mPolygon,
            int&nbsp;level,
            boolean&nbsp;firstIteration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#addToMessageBuffer(java.lang.String)">addToMessageBuffer</A></B>(java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper Methode zum Hinzufuegen von Nachrichten zum globalen Nachrichten-Buffer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../algorithm/ResultVertex.html" title="class in algorithm">ResultVertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#addToResultBuffer(algorithm.ResultVertex)">addToResultBuffer</A></B>(<A HREF="../algorithm/ResultVertex.html" title="class in algorithm">ResultVertex</A>&nbsp;vertex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fuegt ein ResultVertex zum globalen Result-Buffer hinzu</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#analyzeEvents()">analyzeEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode analysiert alle aufgetretenen Events und prueft, ob das Ergebnis plausibel ist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#calculateVertexChildPosition(float, graphics.MyVector3f, graphics.MyVector3f)">calculateVertexChildPosition</A></B>(float&nbsp;targetHeight,
                             <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;direction,
                             <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;currentPosition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;berechnet fuer die aktuelle Position und den aktuellen
 Verschiebungsvektor die Position des Kindes auf der Zielhoehe</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#computeHeightEvents()">computeHeightEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;durchlaeuft alle Vertices und berechnet Schnittpunkte von je 2 adjazenten
  Ebenen mit allen anderen Ebenen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#computeVertexChildPosition(float, algorithm.SkeletonVertex)">computeVertexChildPosition</A></B>(float&nbsp;targetHeight,
                           <A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;current)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#createChildrenForSplitEvent(algorithm.SplitEvent)">createChildrenForSplitEvent</A></B>(<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode erzeugt Kinder fuer SplitEvents, je ein "Original"-Kind und ein Zwilling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#createChildrenForVertexEvent(algorithm.VertexEvent)">createChildrenForVertexEvent</A></B>(<A HREF="../algorithm/VertexEvent.html" title="class in algorithm">VertexEvent</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode erzeugt Kinder fuer VertexEvents, jedes Parent-Vertex bekommt ein eigenes Kind</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../algorithm/VertexEvent.html" title="class in algorithm">VertexEvent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#createVertexEventForSchnittpunkt(graphics.MyVector3f)">createVertexEventForSchnittpunkt</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;schnittpunkt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ersetzt alle SplitEvents im Event-Buffer, die den uebergebenen Schnittpunkt besitzen, 
 durch ein Vertex-Event</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#detectSplitEvents()">detectSplitEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode analysiert die berechneten HeightEvents dahingehend, ob es sich um Split-Events handelt
 Ein HeightEvent ist dann ein Split-Event, wenn es den Schnittpunkt nur einmal gibt und das ausloesende
 Vertex ein Reflex-Vertex ist</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#detectVertexEvents()">detectVertexEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testet, ob zwei oder mehr Split-Events im selben Schnittpunkt auftreten.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#detectVertexEventsNewSchool()">detectVertexEventsNewSchool</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet Vertex-Events, in dem Schnittpunkt von Split-Events ausgwertet werden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#doVertexComputations()">doVertexComputations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#getAllParentsForVertex(algorithm.SkeletonVertex)">getAllParentsForVertex</A></B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode durchlaeuft alle Vertices im Eingabepolygon des aktuellen Jobs und fuegt saemtliche
 Vertices, die das uebergebene Vertex als Kind haben, zum Rueckgabevektor hinzu</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#getLevel()">getLevel</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#getParentNodeForVertex(algorithm.SkeletonVertex)">getParentNodeForVertex</A></B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;current)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Berechnet ein Elternvertex innerhalb der Graphenhierarchie.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#getPolygon()">getPolygon</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#hasReachedEnd()">hasReachedEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testet das Abbruchkriterium des Algorithmus breche ab, wenn keine Events
 mehr festgestellt werden => dann schrumpft das Polygon nicht mehr oder
 die die Anzahl an Vertices <= 2 ist => in diesem Fall ist der
 Flaecheninhalt 0</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#initializeNextIteration()">initializeNextIteration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bereitet den naechsten Iterationsschritt vor, sofern ein Split-Event waehrend der Berechnung aufgetreten ist,
  wird das Eingabepolygon in mehrere Polygone aufgespalten, fuer jedes dieser Polygone wird dann ein neuer Job zur
  globalen Job-Queue hinzugefuegt</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#isValidEvent(algorithm.HeightEvent)">isValidEvent</A></B>(<A HREF="../algorithm/HeightEvent.html" title="class in algorithm">HeightEvent</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testet, ob der berechnete Event gueltig ist => ein Event ist gueltig,
 wenn 
 - die beteiligten Vertices alle direkte Nachbarn sind (EdgeEvent) 
 - das ausloesende Vertex ein Reflex-Vertex ist (SplitEvent)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#isValidIntersection(graphics.MyVector3f, algorithm.SkeletonVertex)">isValidIntersection</A></B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;schnittpunkt,
                    <A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;testVertex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode validiert Schnittpunkte, ein Schnittpunkt ist gueltig, wenn er
 sich innerhalb der moeglichen Flaechen aller 3 beteilgiten Planes
 befindet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#preprocessEventBuffer()">preprocessEventBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entfernt alle Events mit zu grosser Distanz</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#printEventBuffer(java.lang.String)">printEventBuffer</A></B>(java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility-Methode: Ausgabe aller aufgetretenen Events im Event-Buffer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#printJobResult()">printJobResult</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility-Methode: durchlaeuft den gesamten Child-Buffer und gibt die Nachbarn saemtlicher Vertices aus</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#processEvents()">processEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verarbeitet alle auftretenden Events, erzeugt Vertex-Kinder und aktualisiert die Graphbeziehungen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#processSplitEventsOnEdge(java.util.Vector)">processSplitEventsOnEdge</A></B>(java.util.Vector&lt;<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&gt;&nbsp;events)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode aktualisiert die Nachbarn fuer eine beliebige Anzahl von Split-Events auf der selben Kante</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#recoverFromErrors()">recoverFromErrors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode versucht nach dem Auftreten von Fehlern Vertices, die nicht als SkeletonNodes gekennzeichnet sind,
 zum Result-Buffer hinzuzufuegen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#run()">run</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hauptverarbeitungsroutine eines SkeletonJobs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#shrink()">shrink</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#shrinkNewSchool()">shrinkNewSchool</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuehrt das Shrinking derart durch, dass alle Kanten in Richtung ihrer
 Slope-Planes verschoben werden bis sie die Zielhoehe des
 High-Priority-Events erreichen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#sortEventsByDistance()">sortEventsByDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sortierroutine => sortiert den Event-Vektor basierend auf den Distanzwerten</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#sortVerticesBySplitVertexDistance(java.util.Vector)">sortVerticesBySplitVertexDistance</A></B>(java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;&nbsp;vertices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sortiert den uebergebenen Vector von Vertices basierend auf der Distanz
  des Vertices zum adjazenten Vertex eines Split-Events (dient vorrangig der Berechnung des Sonderfalls mehrerer
   Splits auf einer Kante</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#splitPolygon()">splitPolygon</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuehrt die Aufteilung des Child-Buffer-Polygons in zwei einzelne Polygone
 durch man startet immer beim Kind des ausloesenden Events und geht dann
 im Uhrzeigersinn durch den Graph anschliessend macht man das Gleiche mit
 dem Zwilling => wegen der Nachbarschaften muessen die Vertexmengen
 disjunkt sein</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighbours()">updateNeighbours</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated die Neighbours aller Vertices, die keinen Event ausgeloest haben
  gibt jedem Kind eines Vertices die Kinder seiner Nachbarn als neue Nachbarn</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighboursForEvents()">updateNeighboursForEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighboursForHeightEvents()">updateNeighboursForHeightEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode aktualisiert die Nachbarn fuer Edge-Events
 Jedes Event-Vertex versucht, beide Nachbarn zu aktualisieren, sollten diese Nachbarn bereits gesetzt sein,
 so aktualisiert das Vertex nur dann den Nachbarn, falls der gesetzte Nachbar er selber sein sollte</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighboursForSingleSplitEvent(algorithm.SplitEvent, java.util.Vector)">updateNeighboursForSingleSplitEvent</A></B>(<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&nbsp;event,
                                    java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;&nbsp;verticesOnEdge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode fuehrt die Updates fuer ein einzelnes Split-Event durch und greift dabei auf den Edge-Vertex-Buffer zurueck</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighboursForSplitEvents()">updateNeighboursForSplitEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode fuehrt die Nachbarschaftsupdates fuer Split-Events durch</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateNeighboursForVertexEvents()">updateNeighboursForVertexEvents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methode fuehrt die Nachbarschaftsupdates fuer VertexEvent-Vertices durch, vereinfachend geht man davon aus,
 dass keine zwei Vertex-Events auf der selben Kante entstehen koennen</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../algorithm/SkeletonJob.html#updateResultBuffer()">updateResultBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;durchlaufe alle Events und fuege Result-Vertices zum Result-Buffer hinzu</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="mPolygon"><!-- --></A><H3>
mPolygon</H3>
<PRE>
private <A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A> <B>mPolygon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mCompletedFirstIteration"><!-- --></A><H3>
mCompletedFirstIteration</H3>
<PRE>
private boolean <B>mCompletedFirstIteration</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mFoundReflexVertex"><!-- --></A><H3>
mFoundReflexVertex</H3>
<PRE>
private boolean <B>mFoundReflexVertex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mVertexEventPossible"><!-- --></A><H3>
mVertexEventPossible</H3>
<PRE>
private boolean <B>mVertexEventPossible</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mSplitEventOccured"><!-- --></A><H3>
mSplitEventOccured</H3>
<PRE>
private boolean <B>mSplitEventOccured</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mVertexEventOccured"><!-- --></A><H3>
mVertexEventOccured</H3>
<PRE>
private boolean <B>mVertexEventOccured</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mLevel"><!-- --></A><H3>
mLevel</H3>
<PRE>
private int <B>mLevel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mMathHelper"><!-- --></A><H3>
mMathHelper</H3>
<PRE>
private <A HREF="../math/MyVectormath.html" title="class in math">MyVectormath</A> <B>mMathHelper</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mEvents"><!-- --></A><H3>
mEvents</H3>
<PRE>
private java.util.Vector&lt;<A HREF="../algorithm/iStraightSkeletonEvent.html" title="interface in algorithm">iStraightSkeletonEvent</A>&gt; <B>mEvents</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mChildBuffer"><!-- --></A><H3>
mChildBuffer</H3>
<PRE>
private java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt; <B>mChildBuffer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mPolygonBuffer"><!-- --></A><H3>
mPolygonBuffer</H3>
<PRE>
private java.util.Vector&lt;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A>&gt; <B>mPolygonBuffer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mLineBreak"><!-- --></A><H3>
mLineBreak</H3>
<PRE>
private java.lang.String <B>mLineBreak</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mErrorsOccured"><!-- --></A><H3>
mErrorsOccured</H3>
<PRE>
private boolean <B>mErrorsOccured</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SkeletonJob(algorithm.SkeletonPolygon, int, boolean)"><!-- --></A><H3>
SkeletonJob</H3>
<PRE>
public <B>SkeletonJob</B>(<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A>&nbsp;mPolygon,
                   int&nbsp;level,
                   boolean&nbsp;firstIteration)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="doVertexComputations()"><!-- --></A><H3>
doVertexComputations</H3>
<PRE>
private void <B>doVertexComputations</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="run()"><!-- --></A><H3>
run</H3>
<PRE>
public void <B>run</B>()</PRE>
<DL>
<DD>Hauptverarbeitungsroutine eines SkeletonJobs. Fuehrt alle Schritte von der Verarbeitung des Eingabepolygons
 ueber die Event-Berechnung bis zum Shrinking durch. Testet, ob der Algorithmus terminiert, added sonst einen
 weiteren Job zur globalen Job-Queue
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>run</CODE> in interface <CODE>java.lang.Runnable</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLevel()"><!-- --></A><H3>
getLevel</H3>
<PRE>
public int <B>getLevel</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPolygon()"><!-- --></A><H3>
getPolygon</H3>
<PRE>
public <A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm">SkeletonPolygon</A> <B>getPolygon</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="computeHeightEvents()"><!-- --></A><H3>
computeHeightEvents</H3>
<PRE>
private void <B>computeHeightEvents</B>()</PRE>
<DL>
<DD>durchlaeuft alle Vertices und berechnet Schnittpunkte von je 2 adjazenten
  Ebenen mit allen anderen Ebenen
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sortEventsByDistance()"><!-- --></A><H3>
sortEventsByDistance</H3>
<PRE>
private void <B>sortEventsByDistance</B>()</PRE>
<DL>
<DD>Sortierroutine => sortiert den Event-Vektor basierend auf den Distanzwerten
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="preprocessEventBuffer()"><!-- --></A><H3>
preprocessEventBuffer</H3>
<PRE>
private void <B>preprocessEventBuffer</B>()</PRE>
<DL>
<DD>entfernt alle Events mit zu grosser Distanz
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="detectSplitEvents()"><!-- --></A><H3>
detectSplitEvents</H3>
<PRE>
private void <B>detectSplitEvents</B>()</PRE>
<DL>
<DD>Methode analysiert die berechneten HeightEvents dahingehend, ob es sich um Split-Events handelt
 Ein HeightEvent ist dann ein Split-Event, wenn es den Schnittpunkt nur einmal gibt und das ausloesende
 Vertex ein Reflex-Vertex ist
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="detectVertexEventsNewSchool()"><!-- --></A><H3>
detectVertexEventsNewSchool</H3>
<PRE>
private void <B>detectVertexEventsNewSchool</B>()</PRE>
<DL>
<DD>Berechnet Vertex-Events, in dem Schnittpunkt von Split-Events ausgwertet werden. Fuer jedes Split-Event
 errechnet man einen Strahl vom Reflex-Vertex auf den Schnittpunkt und berechnet Schnitte mit jedem anderen Strahl
 Sofern solche Schnitte existieren, handelt es sich um potentielle Vertex-Events
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="detectVertexEvents()"><!-- --></A><H3>
detectVertexEvents</H3>
<PRE>
private void <B>detectVertexEvents</B>()</PRE>
<DL>
<DD>Testet, ob zwei oder mehr Split-Events im selben Schnittpunkt auftreten. Sofern dies der Fall ist, 
 werden diese Split-Events durch ein Vertex-Event ersetzt
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createVertexEventForSchnittpunkt(graphics.MyVector3f)"><!-- --></A><H3>
createVertexEventForSchnittpunkt</H3>
<PRE>
private <A HREF="../algorithm/VertexEvent.html" title="class in algorithm">VertexEvent</A> <B>createVertexEventForSchnittpunkt</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;schnittpunkt)</PRE>
<DL>
<DD>Ersetzt alle SplitEvents im Event-Buffer, die den uebergebenen Schnittpunkt besitzen, 
 durch ein Vertex-Event
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>schnittpunkt</CODE> - Schnittpunkt fuer den das VertexEvent erstellt wird
<DT><B>Returns:</B><DD>Erzeugter Vertex-Event</DL>
</DD>
</DL>
<HR>

<A NAME="isValidIntersection(graphics.MyVector3f, algorithm.SkeletonVertex)"><!-- --></A><H3>
isValidIntersection</H3>
<PRE>
private boolean <B>isValidIntersection</B>(<A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;schnittpunkt,
                                    <A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;testVertex)</PRE>
<DL>
<DD>Methode validiert Schnittpunkte, ein Schnittpunkt ist gueltig, wenn er
 sich innerhalb der moeglichen Flaechen aller 3 beteilgiten Planes
 befindet. Die adjazenten Planes erfuellen die Bedingung, da sich der
 Punkt auf der Schnittgeraden und somit auch auf beiden Ebenen und dem
 Bereich befindet, den die adjazenten Kanten waehrend des Schrumpfens
 einnehmen koennen. Da die 3. Ebene unbegrenzt ist, muss getestet werden,
 ob sich der Punkt innerhalb der Flaeche befindet, die die Quellkante
 waehrend des Schrumpfens einnehmen kann. Die moegliche Flaeche einer
 Kante ist entweder ein Dreieck oder eine semi-infinite Flaeche begrenzt
 durch die Halbierenden an den Vertices 
 Annaeherung an die begrenzte Flaeche:
 Berechne den Schnittpunkt der Winkelhalbierenden in der Polygonebene und rotiere 
 diesen Schnittpunkt um die Kante, so dass er in der Ebene liegt
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>schnittpunkt</CODE> - Berechneter Schnittpunkt der Plane-Plane-Plane-Intersection-Tests<DD><CODE>testVertex</CODE> - Vertex, dessen Kante mit Index 0 die 3. Ebene innerhalb des Plane-Plane-Plane-Intersection-Tests bildet
<DT><B>Returns:</B><DD>True, falls es sich um eine gueltigen Schnittpunkt handelt, False sonst</DL>
</DD>
</DL>
<HR>

<A NAME="isValidEvent(algorithm.HeightEvent)"><!-- --></A><H3>
isValidEvent</H3>
<PRE>
private boolean <B>isValidEvent</B>(<A HREF="../algorithm/HeightEvent.html" title="class in algorithm">HeightEvent</A>&nbsp;event)</PRE>
<DL>
<DD>testet, ob der berechnete Event gueltig ist => ein Event ist gueltig,
 wenn 
 - die beteiligten Vertices alle direkte Nachbarn sind (EdgeEvent) 
 - das ausloesende Vertex ein Reflex-Vertex ist (SplitEvent)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="processEvents()"><!-- --></A><H3>
processEvents</H3>
<PRE>
private void <B>processEvents</B>()</PRE>
<DL>
<DD>verarbeitet alle auftretenden Events, erzeugt Vertex-Kinder und aktualisiert die Graphbeziehungen
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shrink()"><!-- --></A><H3>
shrink</H3>
<PRE>
private void <B>shrink</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>fuehrt die Schrumpfungsberechnungen durch => verschiebt alle Vertices
 derart, dass sie auf die gleiche Hoehe wie die Events gebracht werden
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shrinkNewSchool()"><!-- --></A><H3>
shrinkNewSchool</H3>
<PRE>
private void <B>shrinkNewSchool</B>()</PRE>
<DL>
<DD>fuehrt das Shrinking derart durch, dass alle Kanten in Richtung ihrer
 Slope-Planes verschoben werden bis sie die Zielhoehe des
 High-Priority-Events erreichen. Auf dieser Hoehe berechnet man dann die
 Vertexkinder als Schnittpunkte der adjazenten Kanten
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createChildrenForSplitEvent(algorithm.SplitEvent)"><!-- --></A><H3>
createChildrenForSplitEvent</H3>
<PRE>
private void <B>createChildrenForSplitEvent</B>(<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&nbsp;event)</PRE>
<DL>
<DD>Methode erzeugt Kinder fuer SplitEvents, je ein "Original"-Kind und ein Zwilling
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - Split-Event fuer das die Kinder erzeugt werden</DL>
</DD>
</DL>
<HR>

<A NAME="createChildrenForVertexEvent(algorithm.VertexEvent)"><!-- --></A><H3>
createChildrenForVertexEvent</H3>
<PRE>
private void <B>createChildrenForVertexEvent</B>(<A HREF="../algorithm/VertexEvent.html" title="class in algorithm">VertexEvent</A>&nbsp;event)</PRE>
<DL>
<DD>Methode erzeugt Kinder fuer VertexEvents, jedes Parent-Vertex bekommt ein eigenes Kind
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - VertexEvent, fuer das die Kinder angelegt werden</DL>
</DD>
</DL>
<HR>

<A NAME="calculateVertexChildPosition(float, graphics.MyVector3f, graphics.MyVector3f)"><!-- --></A><H3>
calculateVertexChildPosition</H3>
<PRE>
private <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>calculateVertexChildPosition</B>(float&nbsp;targetHeight,
                                                <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;direction,
                                                <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A>&nbsp;currentPosition)</PRE>
<DL>
<DD>berechnet fuer die aktuelle Position und den aktuellen
 Verschiebungsvektor die Position des Kindes auf der Zielhoehe
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateResultBuffer()"><!-- --></A><H3>
updateResultBuffer</H3>
<PRE>
private void <B>updateResultBuffer</B>()</PRE>
<DL>
<DD>durchlaufe alle Events und fuege Result-Vertices zum Result-Buffer hinzu
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="computeVertexChildPosition(float, algorithm.SkeletonVertex)"><!-- --></A><H3>
computeVertexChildPosition</H3>
<PRE>
private <A HREF="../graphics/MyVector3f.html" title="class in graphics">MyVector3f</A> <B>computeVertexChildPosition</B>(float&nbsp;targetHeight,
                                              <A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;current)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>Methode verschiebt Vertices orthogonal (verwendet die skalierte
  Vertex-Normale zur Grundebene auf die Zielhoehe
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>targetHeight</CODE> - Zielhoehe, auf der sich das Kindvertex befinden soll<DD><CODE>current</CODE> - Vertex, fuer das die Verschiebungsberechnungen durchgefuehrt werden sollen</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighbours()"><!-- --></A><H3>
updateNeighbours</H3>
<PRE>
private void <B>updateNeighbours</B>()</PRE>
<DL>
<DD>updated die Neighbours aller Vertices, die keinen Event ausgeloest haben
  gibt jedem Kind eines Vertices die Kinder seiner Nachbarn als neue Nachbarn
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighboursForEvents()"><!-- --></A><H3>
updateNeighboursForEvents</H3>
<PRE>
private void <B>updateNeighboursForEvents</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>fuehrt die speziellen Neighbour-Updates fuer Event-ausloesende Vertices
 durch jedes Event updated nur genau einen Nachbarn des Event-Childs =>
 haengt mit der Berechnungsabfolge der Events zusammen => diese werden
 immer im Uhrzeigersinn berechnet, da das Sortierverfahren stabil ist
 weiss man immer, welchen Nachbarn ein Event updaten muss (immer den
 naechsten noch nicht gesetzten!)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighboursForHeightEvents()"><!-- --></A><H3>
updateNeighboursForHeightEvents</H3>
<PRE>
private void <B>updateNeighboursForHeightEvents</B>()</PRE>
<DL>
<DD>Methode aktualisiert die Nachbarn fuer Edge-Events
 Jedes Event-Vertex versucht, beide Nachbarn zu aktualisieren, sollten diese Nachbarn bereits gesetzt sein,
 so aktualisiert das Vertex nur dann den Nachbarn, falls der gesetzte Nachbar er selber sein sollte
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighboursForSplitEvents()"><!-- --></A><H3>
updateNeighboursForSplitEvents</H3>
<PRE>
private void <B>updateNeighboursForSplitEvents</B>()</PRE>
<DL>
<DD>Methode fuehrt die Nachbarschaftsupdates fuer Split-Events durch
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighboursForVertexEvents()"><!-- --></A><H3>
updateNeighboursForVertexEvents</H3>
<PRE>
private void <B>updateNeighboursForVertexEvents</B>()</PRE>
<DL>
<DD>Methode fuehrt die Nachbarschaftsupdates fuer VertexEvent-Vertices durch, vereinfachend geht man davon aus,
 dass keine zwei Vertex-Events auf der selben Kante entstehen koennen
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="processSplitEventsOnEdge(java.util.Vector)"><!-- --></A><H3>
processSplitEventsOnEdge</H3>
<PRE>
private void <B>processSplitEventsOnEdge</B>(java.util.Vector&lt;<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&gt;&nbsp;events)</PRE>
<DL>
<DD>Methode aktualisiert die Nachbarn fuer eine beliebige Anzahl von Split-Events auf der selben Kante
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>events</CODE> - Vektor mit einer Menge von SplitEvents, die alle auf der gleichen Kante auftreten</DL>
</DD>
</DL>
<HR>

<A NAME="sortVerticesBySplitVertexDistance(java.util.Vector)"><!-- --></A><H3>
sortVerticesBySplitVertexDistance</H3>
<PRE>
private void <B>sortVerticesBySplitVertexDistance</B>(java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;&nbsp;vertices)</PRE>
<DL>
<DD>sortiert den uebergebenen Vector von Vertices basierend auf der Distanz
  des Vertices zum adjazenten Vertex eines Split-Events (dient vorrangig der Berechnung des Sonderfalls mehrerer
   Splits auf einer Kante
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertices</CODE> - Vektor mit allen Vertices, die auf dieser Kante angeordnet werden muessen</DL>
</DD>
</DL>
<HR>

<A NAME="updateNeighboursForSingleSplitEvent(algorithm.SplitEvent, java.util.Vector)"><!-- --></A><H3>
updateNeighboursForSingleSplitEvent</H3>
<PRE>
private void <B>updateNeighboursForSingleSplitEvent</B>(<A HREF="../algorithm/SplitEvent.html" title="class in algorithm">SplitEvent</A>&nbsp;event,
                                                 java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt;&nbsp;verticesOnEdge)</PRE>
<DL>
<DD>Methode fuehrt die Updates fuer ein einzelnes Split-Event durch und greift dabei auf den Edge-Vertex-Buffer zurueck
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - SplitEvent fuer dessen Kindvertices die Nachbarschaftsupdates durchgefuehrt werden<DD><CODE>verticesOnEdge</CODE> - Vektor mit SkeletonVertices, die basierend auf ihrer Distanz zum Startvertex der Eventkante sortiert sind</DL>
</DD>
</DL>
<HR>

<A NAME="initializeNextIteration()"><!-- --></A><H3>
initializeNextIteration</H3>
<PRE>
private void <B>initializeNextIteration</B>()</PRE>
<DL>
<DD>bereitet den naechsten Iterationsschritt vor, sofern ein Split-Event waehrend der Berechnung aufgetreten ist,
  wird das Eingabepolygon in mehrere Polygone aufgespalten, fuer jedes dieser Polygone wird dann ein neuer Job zur
  globalen Job-Queue hinzugefuegt
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasReachedEnd()"><!-- --></A><H3>
hasReachedEnd</H3>
<PRE>
private boolean <B>hasReachedEnd</B>()</PRE>
<DL>
<DD>testet das Abbruchkriterium des Algorithmus breche ab, wenn keine Events
 mehr festgestellt werden => dann schrumpft das Polygon nicht mehr oder
 die die Anzahl an Vertices <= 2 ist => in diesem Fall ist der
 Flaecheninhalt 0
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="splitPolygon()"><!-- --></A><H3>
splitPolygon</H3>
<PRE>
private void <B>splitPolygon</B>()</PRE>
<DL>
<DD>fuehrt die Aufteilung des Child-Buffer-Polygons in zwei einzelne Polygone
 durch man startet immer beim Kind des ausloesenden Events und geht dann
 im Uhrzeigersinn durch den Graph anschliessend macht man das Gleiche mit
 dem Zwilling => wegen der Nachbarschaften muessen die Vertexmengen
 disjunkt sein
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addToResultBuffer(algorithm.ResultVertex)"><!-- --></A><H3>
addToResultBuffer</H3>
<PRE>
private <A HREF="../algorithm/ResultVertex.html" title="class in algorithm">ResultVertex</A> <B>addToResultBuffer</B>(<A HREF="../algorithm/ResultVertex.html" title="class in algorithm">ResultVertex</A>&nbsp;vertex)</PRE>
<DL>
<DD>Fuegt ein ResultVertex zum globalen Result-Buffer hinzu
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertex</CODE> - Das hinzuzufuegende ResultVertex
<DT><B>Returns:</B><DD>Sofern das Vertex bereits im ResultBuffer vorhanden war, gibt die Methode einen Pointer auf das vorhandene Vertex zurueck, sonst einen Pointer auf das gerade hinzugefuegte</DL>
</DD>
</DL>
<HR>

<A NAME="getParentNodeForVertex(algorithm.SkeletonVertex)"><!-- --></A><H3>
getParentNodeForVertex</H3>
<PRE>
private <A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A> <B>getParentNodeForVertex</B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;current)</PRE>
<DL>
<DD>Berechnet ein Elternvertex innerhalb der Graphenhierarchie. Ziel ist die Bestimmung eines Elternvertex, das
 entweder ein SkeletonNode ist oder keinen Elternknoten mehr hat
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - Vertex, fuer das der Elternknoten gesucht wird
<DT><B>Returns:</B><DD>Der gefundene Elternknoten</DL>
</DD>
</DL>
<HR>

<A NAME="printJobResult()"><!-- --></A><H3>
printJobResult</H3>
<PRE>
private void <B>printJobResult</B>()</PRE>
<DL>
<DD>Utility-Methode: durchlaeuft den gesamten Child-Buffer und gibt die Nachbarn saemtlicher Vertices aus
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printEventBuffer(java.lang.String)"><!-- --></A><H3>
printEventBuffer</H3>
<PRE>
private void <B>printEventBuffer</B>(java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD>Utility-Methode: Ausgabe aller aufgetretenen Events im Event-Buffer
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="analyzeEvents()"><!-- --></A><H3>
analyzeEvents</H3>
<PRE>
private void <B>analyzeEvents</B>()</PRE>
<DL>
<DD>Methode analysiert alle aufgetretenen Events und prueft, ob das Ergebnis plausibel ist. EdgeEvents sind
 bsw. ungueltig, diese einen Schnittpunkt aufweisen, der in keinem anderen Event vorkommt. Treten solche Events
 auf, schreibt die Methode Fehlermeldungen in die Hauptverarbeitung
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addToMessageBuffer(java.lang.String)"><!-- --></A><H3>
addToMessageBuffer</H3>
<PRE>
private void <B>addToMessageBuffer</B>(java.lang.String&nbsp;message)</PRE>
<DL>
<DD>Wrapper Methode zum Hinzufuegen von Nachrichten zum globalen Nachrichten-Buffer
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="recoverFromErrors()"><!-- --></A><H3>
recoverFromErrors</H3>
<PRE>
private void <B>recoverFromErrors</B>()</PRE>
<DL>
<DD>Methode versucht nach dem Auftreten von Fehlern Vertices, die nicht als SkeletonNodes gekennzeichnet sind,
 zum Result-Buffer hinzuzufuegen. Diese Vertices koennen waehrend des Schrumpfungsprozesses gueltige SkeletonNodes sein,
 die allerdings durch das Loeschen ungueltiger Events nicht als solche gekennzeichnet sind. Die Methode fuegt alle Nodes
 und ihre Eltern im Child-Buffer, die keine SkeletonNodes sind, zum Result-Buffer hinzu.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllParentsForVertex(algorithm.SkeletonVertex)"><!-- --></A><H3>
getAllParentsForVertex</H3>
<PRE>
private java.util.Vector&lt;<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&gt; <B>getAllParentsForVertex</B>(<A HREF="../algorithm/SkeletonVertex.html" title="class in algorithm">SkeletonVertex</A>&nbsp;child)</PRE>
<DL>
<DD>Methode durchlaeuft alle Vertices im Eingabepolygon des aktuellen Jobs und fuegt saemtliche
 Vertices, die das uebergebene Vertex als Kind haben, zum Rueckgabevektor hinzu
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>child</CODE> - Vertex, dessen Eltern durch die Methode gefunden werden sollen
<DT><B>Returns:</B><DD>Vektor mit allen Vertices, die Eltern des uebergebenen Kindes sind</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SkeletonJob.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../algorithm/SkeletonEdge.html" title="class in algorithm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../algorithm/SkeletonPolygon.html" title="class in algorithm"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?algorithm/SkeletonJob.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SkeletonJob.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
